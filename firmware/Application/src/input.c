#include "input.h"
#include <main.h>
#include <FreeRTOS.h>
#include <task.h>

// Input uses a Bourns ACE 128 position rotary encoder connected to an NXP PCAL6416A I2C I/O expander. There are also two "channel in stand" sensors connected to the same IC.

// This is the map between binary value read from the encoder and the 128 step position
// (from 0 - 127 inclusive). Invalid binary values are set to a position of 0xff.
static const uint8_t ace_map[256] =
{
	0xff, 0x38, 0x28, 0x37, 0x18, 0xff, 0x27, 0x34, 0x08, 0x39, 0xff, 0xff, 0x17, 0xff, 0x24, 0x0d,
	0x78, 0xff, 0x29, 0x36, 0xff, 0xff, 0xff, 0x35, 0x07, 0xff, 0xff, 0xff, 0x14, 0x13, 0x7d, 0x12,
	0x68, 0x69, 0xff, 0xff, 0x19, 0x6a, 0x26, 0xff, 0xff, 0x3a, 0xff, 0xff, 0xff, 0xff, 0x25, 0x0e,
	0x77, 0x76, 0xff, 0xff, 0xff, 0x6b, 0xff, 0xff, 0x04, 0xff, 0x03, 0xff, 0x6d, 0x6c, 0x02, 0x01,
	0x58, 0xff, 0x59, 0xff, 0xff, 0xff, 0xff, 0x33, 0x09, 0x0a, 0x5a, 0xff, 0x16, 0x0b, 0xff, 0x0c,
	0xff, 0xff, 0x2a, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0xff, 0x7e, 0x7f,
	0x67, 0xff, 0x66, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5b, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x74, 0x75, 0xff, 0xff, 0x73, 0xff, 0xff, 0xff, 0x5d, 0x5e, 0x5c, 0xff, 0x72, 0x5f, 0x71, 0x00,
	0x48, 0x47, 0xff, 0x44, 0x49, 0xff, 0xff, 0x1d, 0xff, 0x46, 0xff, 0x45, 0xff, 0xff, 0x23, 0x22,
	0x79, 0xff, 0x7a, 0xff, 0x4a, 0xff, 0xff, 0x1e, 0x06, 0xff, 0x7b, 0xff, 0xff, 0xff, 0x7c, 0x11,
	0xff, 0xff, 0xff, 0x43, 0x1a, 0xff, 0x1b, 0x1c, 0xff, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0xff, 0xff, 0xff, 0x6e, 0xff, 0x6f, 0x10,
	0x57, 0x54, 0xff, 0x2d, 0x56, 0x55, 0xff, 0x32, 0xff, 0xff, 0xff, 0x2e, 0xff, 0xff, 0xff, 0x21,
	0xff, 0x53, 0xff, 0x2c, 0x4b, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20,
	0x64, 0x3d, 0x65, 0x42, 0xff, 0x3e, 0xff, 0x31, 0x63, 0x3c, 0xff, 0x2f, 0xff, 0xff, 0xff, 0x30,
	0x4d, 0x52, 0x4e, 0x41, 0x4c, 0x3f, 0xff, 0x40, 0x62, 0x51, 0x4f, 0x50, 0x61, 0x60, 0x70, 0xff
};

static bool changed;
static bool read;

static portTASK_FUNCTION_PROTO(task, parameters);

I2C_HandleTypeDef hi2c1;
DMA_HandleTypeDef hdma_i2c1_rx;

#define IOEXP_ADDR_WR 0b01000000
#define IOEXP_ADDR_RD 0b01000001
#define IOEXP_TIMEOUT (1 / HAL_GetTickFreq())

static const uint8_t ioexp_init_commands[][3] =
{
	{0x46, 0b11111111, 0b00000011}, // Enable pullups for all port 0 inputs and two port 1 bits
	{0x4a, 0b00000000, 0b11111100} // Enable interrupts for all port 0 inputs, and two port 1 bits
};
static const uint8_t ioexp_read_input_command[] = { 0x00 };

static uint16_t ioexp_value;


static void ioexp_write(const uint8_t* data, uint16_t size)
{
	if (HAL_I2C_Master_Transmit(&hi2c1, IOEXP_ADDR_WR, (uint8_t*)data, size, IOEXP_TIMEOUT) != HAL_OK)
	{
		Error_Handler();
	}
}

static void ioexp_read(uint8_t* data, uint16_t size)
{
	if (HAL_I2C_Master_Receive(&hi2c1, IOEXP_ADDR_RD, data, size, IOEXP_TIMEOUT) != HAL_OK)
	{
		Error_Handler();
	}
}

static void ioexp_handle_interrupt(void)
{

}

void input_initialise(void)
{
	// Enable pull up resistors for I2C bus
	HAL_GPIO_WritePin(GPIOB, SCL_PU_Pin|SDA_PU_Pin, GPIO_PIN_RESET);

	// Enable pull up resistors on the I/O expander
	size_t i;
	for (i = 0; i < sizeof(ioexp_init_commands) / sizeof(ioexp_init_commands[0]); ++i)
	{
		ioexp_write(ioexp_init_commands[i], sizeof(ioexp_init_commands[i]));
	}

	// Get the current inputs
	ioexp_write(ioexp_read_input_command, sizeof(ioexp_read_input_command));
	ioexp_read((uint8_t*)&ioexp_value, sizeof(ioexp_value));

	// Initialise variables
	changed = true;
	read = true;

	// Set up an interrupt handler to handle input changes
	EXTI_HandleTypeDef exti_handle;
	EXTI_ConfigTypeDef exti_config;
	exti_config.GPIOSel = EXTI_GPIOC;
	exti_config.Line = EXTI_LINE_13;
	exti_config.Mode = EXTI_MODE_INTERRUPT;
	exti_config.Trigger = EXTI_TRIGGER_FALLING;
	if (HAL_EXTI_GetHandle(&exti_handle, EXTI_LINE_13) != HAL_OK ||
		HAL_EXTI_SetConfigLine(&exti_handle, &exti_config) != HAL_OK ||
		HAL_EXTI_RegisterCallback(&exti_handle, HAL_EXTI_COMMON_CB_ID, ioexp_handle_interrupt) != HAL_OK)
	{
		Error_Handler();
	}

	// Set up input task and run it
	xTaskCreate(task, "Input", 128, 0, 10, 0);
}

static portTASK_FUNCTION(task, parameters)
{
	while (true)
	{
		if (changed && read)
		{

		}
	}
}

static void handle_input_change(uint16_t value)
{

}
